                                                                -*-text-*-
                ==============================
                         Coders Guide
                ==============================

Table of Contents

    * Directory Layout
    * Style Information
    * Commenting
    * Code Safety
    * Writing Log Messages



Directory Layout
================

    bin/
        The location of compiled binary files and helper scripts
    data/
        On-disk data files, such as config files
    data/world
        World data files
    doc/
        User and developer documentation
    doc/doxygen
        Generated doxygen documentation
    include/
        Common header files
    src/
        Common source files



Style Information
=================

Never use a non-const global variable without first asking me. And if you ask
me, I will say "No".

Do not use "Hungarian Notation". Violators will be shot. Survivors will be shot
again. (Hungarian Notation is where you put a variable identifier in the
variable name, such as 'iCounter' for an integer, or pNext for a pointer.)

1. Identifier names

    A.  i, j, and k are valid counter variables. Avoid single-letter variable
        everywhere else.

    B.  Choose names carefully.  X, jj, and b2 don't mean as much as timeLeft,
        biggest, and whereNext.

    C.  In multiple-word names, capitalize the first letter of the second and
        later words.  Do not use underscores.  In names of functions, classes,
        types, and global data, capitalize the first letter of the entire
        variable name, too.  Leave the first letter lowercase in locals and
        member data.

        Functions, globals, classes, types:  String   ClearList  TotalSize

        Locals and member data: stringLength  nameNdx  bestScore

    D.  If you abbreviate commonly used terms in variable or type names, use 
        the same abbreviation everywhere. For example, if you abbreviate 
        'catagory' to 'ctg', do it for every variable in which you use the
        word.

    E.  Constants should be named all in CAPITAL_LETTERS. It is acceptable to
        use underscores to separate words in this case, as there is nothing
        else you can do, really.
        
        const int MAGIC_NUMBER = 10;

2. Indentation and Blank Lines

    A.  Use of 4-space tabs (use spaces if your text editor doesn't convert
        them automatically) is manditory. You will be flogged otherwise. :)

    B.  Indent only one level for each nested if, while, or switch. Place the
        opening brace at the end of the first line of the if, while, struct,
        etc. that it applies to. The only exception is the opening brace of a
        function, which goes on a line by itself.

        while (...) {
            statement;

            if (...) {
                statement;
            }
        }

        Indent both the then and else blocks of an if-statement, even if they
        are only one line long. Don't write: if (test) statement;

    C.  Never let a line exceed 78 columns.  If a line must be broken into two,
        indent the second part one space past the opening parathathes, or one
        tab (4 spaces):

        if (some_very_long_test_that_has_a_very_long_name ==
            some_random_long_variable)

    D.  Use blank lines to break up blocks of code. Code should fall into groups
        of about 5 lines on average, separated by a blank line or a line with
        only a brace. Always put a blank line after the local declarations in a
        function. Dont put more than one blank line in a row. A single blank line
        at a time is enough to break up the flow of code properly.

    F.  Indent member functions and member data 4 spaces relative to the "class"
        or "struct" keyword, but do not indent the keywords "private", "public",
        or "protected":

        class Test {
            int Add(void);
        protected:
            float total;
        };

3. Horizontal Whitespace

    A.  Put spaces after each comma, and around each keyword (note that "if",
        "while" and "for" are keywords). Put a space after each semicolon in a
        for header. Never put a space before a comma or semicolon.

    B.  Put spaces around operators, except for operators on the top two rows of
        the precedence table (e.g. [], ++, &) Dont have more than three variables 
        or operators in a row without a blank space. Use parentheses to help
        readability.

        Good:  epsilon = (2 * beta[1]) + *gamma - (delta * pi);
        Bad:   epsilon=2**gamma-delta*pi;

    C.  Put single blank lines after each function, and between local
        declarations and the function code.  

    D.  Don't put space after an opening paren, or before a closing one. Do not
        put space between a function name and the opening paren for the parameter
        list.

4. Function Design

    A.  Functions should hover around 50 lines long, not counting blank lines,
        assertions, or lines containing a single brace. Don't "cram code".
        Break up your functions instead. Functions with long switch statements
        are an exception to this rule.

    B.  Always put local variables at the top of the function, not
        interspersed in the code, unless your function requires delayed
        construction of variables.

5. Class Design

    A.  When defining a type that is just a simple set of data, use the
        keyword 'struct'. If you need methods, use the 'class' keyword.

    B.  Never use a public data member except in structs. If you have a data
        member that you need to freely modify, create accessor functions. The
        accessor functions are 2 public functions with the same name as the
        data member, with 'Get' and 'Set' tacked on to the front.

        class TestClass {
        private:
            int data;
        public:
            int GetData() { return data; }
            void SetData(int value) { data = value; }
        };

    C.  In the implementation of the class (.cpp file), define the member
        functions in the same order that they were declared in the header
        file.

    D.  Include inside the class declaration all types that the class needs
        for it's internal data storage or parameters. Don't declare such types
        outside of the class.

    E.  Use inline member functions, defined inside the class header, whenever
        the function is short enough to fit on one line.

    F.  When a header file foo.h for class foo includes pointers or references
        to class bar, do not include bar.h in foo.h. Such inclusions result in
        tightly interdependent code with attendant long builds. Instead, use
        forward declarations (ex, class Bar; ). Do not put inline functions in
        class foo if they require you to include bar.h unless you have a
        *very* good reason.

6. File Organization

    A.  Files should generally be roughly 600 lines long at most.

    B.  Header files will *always* be wrapped with #ifndef - #endif pairs to
        avoid multiple includes.
        
        #ifndef __HEADER_H
        #define __HEADER_H
        // stuff
        #endif /* __HEADER_H */

    C.  Files should come in .h/.cpp pairs, with each pair defining one class.
        If two class are friends, they can go into the same .h/.cpp pair.
        Definitely do not cram declarations, constants, defines, and classes
        into a big, giant, general purpose .h file.

    D.  Do not use 'using namespace' in header files. If you need it, put it
        in the .cpp file that uses it. Use full namespace scopes in header
        files, and 'using namespace' only in .cpp files.

    E.  Avoid excessive .h file dependencies. Do not include one local .h file
        in another (see 5-F) when forward declarations will suffice.


Example of good style:

int
main(int argc, char* argv[])            // Main function just like this
{                                       // Function braces on their own lines
    int foo, bar;                       // Condense declarations
                                        // Blank lines surrounding ifs
    if (foo) {                          // All other braces "snuggled"
        foo += bar;
        bar++;

        if (--foo)                      // No need for a pair of braces
            bar--;                      // around single statements
    }
                                        // A blank line before 'return'
    return 0;                           // Main always returns 0 on success
}

char *                                  // Function type on own line
RandomFunction(char* arg1, int arg2)    // Function header just like this
{                                       // Function braces on their own lines
    if ((long_bool_check && long_arg)   // Long conditionals should be setup
      || short_arg_check) {             // setup like this, indented 3 spaces
        arg2 = CheckArg(arg1, arg2);    // with ||/&& at beginning of lines
    } else {                            // Else checks with snuggled braces
        arg1 = CheckArg(arg1, arg2);
		arg2 = 0;
    }

    return (char);
}

int
IntFunction(void)                       // Specify (void) if a function has no
{                                       // paramters
    DoSomething(arg1, arg2);            // No space after function name
    DoSomething2(arg1, arg2);           // Spaces between function arguments

    return (0);                         // Always use an explicit return
}                                       // statement



Commeting
=========

Every function must start out with a documentation comment that describes 
what the function does.  The comment should mention every parameter passed to 
the function, every possible return value, and every condition where the
function would return an error.

For classes and data structures, the comment should describe every member of
the class/struct as well as the class/struct itself.  Member functions should
only be touched upon, though, if at all.  They should be covered in their own 
comment blocks.

All interface comment blocks should be located in the header files, above the
function/class/struct declaration.  This is to avoid cluttering the code with
long comment strings.

We will be using doxygen (http://www.doxygen.org/) for interface and API 
documentation.  You should always use the doxygen format for the interface 
comments (the ones describing the function/class/struct).

In-code comments should be sparse and only where absolutely required to
understand the code.  If necessary, put a comment marker above the code in
question that refers back to the interface documentation. For example:

    [ file.h ]
    /**
     * A nifty function to do nifty stuff
     *
     * (1) This bit of code loops forever, causing data loss, terrorism, and
     * the summoning of Satan.
     */
    int
    DoSomethingNifty(void);

    [ file.cpp ]
    int
    DoSomethingNifty(void)
    {
        // (1)
        code comes here
        and here
        and here
    }



Code Safety
===========

1.  Use assertions to check input assumptions on functions, and to check the
    outcome of large or complex blocks of code. Assertions should only be used
    to check for bugs in the code, not to cover user or file format errors.
    Use exceptions for these. Write an assertion only if you would change the
    code if the assertion fails.

2.  Always add a 'default' case to a switch statement. If the default case
    should never be reached, place an 'assert(0)' under it.

3.  When you delete/free data, immediately set the pointer to NULL. This
    prevents double-deletion/double-free errors and accidental use of deleted
    data.
        
        delete pointer;
        pointer = NULL;

4.  Initialize all member data in the class constructor, even if you plan to
    reassign it later.



Writing Log Messages
====================

To start with, log messages are required on all commits.  If you forget a log
mesage on your commit, or you need to edit an old log message, you can easily
fix that by running the following commands, where N is the revision number.

$ svn propedit svn:log -rN --revprop
or
$ svn propset svn:log "log message"  -rN --revprop

Log messages should start off describing the change you are making.  Write a
one-line intro/summary, and then expand if necessary.  Make your log messages
meaningful and use full sentences and correct grammar.  Try to avoid sentence
fragments.  In certain cases, fragments are acceptable.  For example, "Bug 
fix", "Typo", or "New file/function" are self-explainatory, and details 
should, of course, appear in the source code.

After your summary/intro/explaination, you should include detailed information
about every file/function that has changed.  The message should name every
function, variable, macro, etc, that has changed in this commit, especially if
it has been removed.  This helps when searching through the logs later on.
Avoid using wildcards (ex, *), as that makes it more difficult to grep the
logs properly.

Log messages should follow the format:

    * <filename>:
      <change>

    * <filename>
      (<data structures modified>):
      <change>

Some example log messages:

    * src/main.cpp:
      Added new helper functions to handle commandline arguments.

    * src/socket.cpp:
      (sock_addr, Socket::New):
      Fixed Socket::New to handle updated sock_addr struct.

    * include/main.h: Fixed indentation and typos.

If you make the same change in multiple files, you can list them all in the 
same entry:

    * src/socket.cpp, src/main.cpp, src/color.cpp:
      Include server.h.

Or you can list multiple files by noting the common prefix before hand:

    [ in src/engine/ ]

    * engine.cpp:
      Deal harshly with bad input data by throwing an exception.

    * ipc.cpp:
      Add new IPC functions for accessing shared memory.

If your commit is fixing an issue from the bug tracker, then include a comment
noting which issue is being fixed:

    Fix issue #162: Handle command-line arguments correctly

    * src/main.cpp:
      Pass argv correctly into the helper functions.

Obviously, common sense still applies.  If you are making trivial changes
throughout the source file, such as renaming a variable, just summarize it in
the log message (ex, "Variable renamed, all callers changed.").  Also, if you
are rewriting a file completely, there is no need to list every change in the
log message.  A simple "File rewritten" will suffice in most cases.

In generally, it is helpful to list the changes in the log message, but avoid
getting overly verbose.  Being terse helps no one, but writing giant log
messages just wastes time.

And finally, don't use log messages as a replacement for comments.  If you 
find yourself trying to describe the code itself, your explaination probably
belongs in a comment before the function, or even above the section of code
itself.
